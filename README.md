# HUAWEI2020code
华为2020软件精英赛初赛(线上评分16.4509)


菜鸡一枚，线上跑分16+，没进复赛。
线下1004812的数据集鲲鹏测试机用时40s。

看到前面全是0.1分大佬，就丧失了优化的动力。
将算法分享一下。

level1:
找7步以内的环，如果简单采用(4+3)DFS模式，一个点一个点找，找完删除该点进行剪枝，会浪费掉搜索过程中的信息。

level2:
比如在对A点进行深度为4的搜索时，实际上相邻节点的距离为3的局部探索也一并完成了，轮到这些点时，又要进行4的搜索，把之前的记忆浪费掉了。
因此，想到用空间换时间的思路，使用N_4_table保存搜索过程中的记忆，也就是相邻节点的距离为3的可达路径信息。已经保存过记忆信息的节点，其visit设置为true,
并加入wait_for_solved队列里.

整个算法由wait_for_solved队列驱动，首先，随机选择(当然，也可以有策略地选择)一个点，进行start_next_4搜索，其相邻节点的距离为3的路径信息，在这次搜索过程中
保存在N_4_table里，并入队，主循环里检测队列，若非空，对头节点出队，并依据其N_4_table的方向、深度等信息选择找环的函数，进行找环，找环函数
(除了起始节点的距离为3的找环)进行距离为4的dfs找环，在找环的同时，也完成保存记忆的功能，即将相邻节点的距离为3的局部路径信息保存在N_4_table里，并和之前一样，
将这些节点，入队。这样当主循环检测到wait_for_solved队列为空时，说明一个强联通分量都找完环了，如果还有未解决的点，则是另一个强联通分量，再重复上述过程。直到所有节点完成找环。


总之，核心思想就是，省去大部分节点的(4+3)DFS模式中的(3)DFS，因为，(3)完全可以由其他节点的(4)DFS得到。
level1表现:鲲鹏测试机，1004812数据集，用时170s
level2表现:鲲鹏测试机，1004812数据集，用时40s


